<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="调度的机制用一句话描述：runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。 基本概念M（machine） M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang的调度模型概览">
<meta property="og:url" content="http://blog.ozy.tech/2018/08/03/Golang的调度模型概览/index.html">
<meta property="og:site_name" content="欧钟艺的博客">
<meta property="og:description" content="调度的机制用一句话描述：runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。 基本概念M（machine） M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-26T02:29:01.538Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang的调度模型概览">
<meta name="twitter:description" content="调度的机制用一句话描述：runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。 基本概念M（machine） M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个">






  <link rel="canonical" href="http://blog.ozy.tech/2018/08/03/Golang的调度模型概览/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Golang的调度模型概览 | 欧钟艺的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欧钟艺的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">要拍照的事 可不少</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.ozy.tech/2018/08/03/Golang的调度模型概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="欧钟艺">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欧钟艺的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Golang的调度模型概览
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-03 09:38:06" itemprop="dateCreated datePublished" datetime="2018-08-03T09:38:06+08:00">2018-08-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-26 10:29:01" itemprop="dateModified" datetime="2019-02-26T10:29:01+08:00">2019-02-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>调度的机制用一句话描述：<br>runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="M（machine）"><a href="#M（machine）" class="headerlink" title="M（machine）"></a>M（machine）</h4><ul>
<li>M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</li>
<li>M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。</li>
<li>M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。</li>
</ul>
<a id="more"></a>
<h4 id="P（processor）"><a href="#P（processor）" class="headerlink" title="P（processor）"></a>P（processor）</h4><ul>
<li>P表示逻辑processor，是线程M的执行的上下文。</li>
<li>P的最大作用是其拥有的各种G对象队列、链表、cache和状态。</li>
</ul>
<h4 id="G（goroutine）"><a href="#G（goroutine）" class="headerlink" title="G（goroutine）"></a>G（goroutine）</h4><ul>
<li>调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</li>
<li>在G的眼中只有P，P就是运行G的“CPU”。</li>
<li>相当于两级线程</li>
</ul>
<h4 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h4><p>来自<code>Go并发编程实战</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                    +-------+       +-------+      </span><br><span class="line">                    |  KSE  |       |  KSE  |          </span><br><span class="line">                    +-------+       +-------+      </span><br><span class="line">                        |               |                       内核空间</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        </span><br><span class="line">                        |               |                       用户空间</span><br><span class="line">                    +-------+       +-------+</span><br><span class="line">                    |   M   |       |   M   |</span><br><span class="line">                    +-------+       +-------+</span><br><span class="line">                  |          |         |          |</span><br><span class="line">              +------+   +------+   +------+   +------+            </span><br><span class="line">              |   P  |   |   P  |   |   P  |   |   P  |</span><br><span class="line">              +------+   +------+   +------+   +------+   </span><br><span class="line">           |     |     |     |     |     |     |     |     | </span><br><span class="line">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ </span><br><span class="line">         | G | | G | | G | | G | | G | | G | | G | | G | | G | </span><br><span class="line">         +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+</span><br></pre></td></tr></table></figure></p>
<ul>
<li>KSE（Kernel Scheduling Entity）是内核调度实体           </li>
<li>M与P，P与G之前的关联都是动态的，可以变的</li>
</ul>
<h3 id="关系示意图"><a href="#关系示意图" class="headerlink" title="关系示意图"></a>关系示意图</h3><p>来自<code>golang源码剖析</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                            +-------------------- sysmon ---------------//------+ </span><br><span class="line">                            |                                                   |</span><br><span class="line">                            |                                                   |</span><br><span class="line">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class="line">go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M |</span><br><span class="line">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class="line">                            |                                 |                 | </span><br><span class="line">                            |      +---+                      |                 |</span><br><span class="line">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--//--+</span><br><span class="line">                                   +---+ </span><br><span class="line">                                     |</span><br><span class="line">                                   mstart</span><br><span class="line">                                     |</span><br><span class="line">              +--- execute &lt;----- schedule </span><br><span class="line">              |                      |   </span><br><span class="line">              |                      |</span><br><span class="line">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              1. go func() 语气创建G。</span><br><span class="line">              2. 将G放入P的本地队列（或者平衡到全局全局队列）。</span><br><span class="line">              3. 唤醒或新建M来执行任务。</span><br><span class="line">              4. 进入调度循环</span><br><span class="line">              5. 尽力获取可执行的G，并执行</span><br><span class="line">              6. 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure></p>
<h2 id="GPM的来由"><a href="#GPM的来由" class="headerlink" title="GPM的来由"></a>GPM的来由</h2><h3 id="特殊的g0和m0"><a href="#特殊的g0和m0" class="headerlink" title="特殊的g0和m0"></a>特殊的g0和m0</h3><p>g0和m0是在<code>proc.go</code>文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack<br><code>asm_amd64.go</code> –&gt; runtime·rt0_go(SB)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序刚启动的时候必定有一个线程启动（主线程）</span></span><br><span class="line"><span class="comment">// 将当前的栈和资源保存在g0</span></span><br><span class="line"><span class="comment">// 将该线程保存在m0</span></span><br><span class="line"><span class="comment">// tls: Thread Local Storage</span></span><br><span class="line"><span class="comment">// set the per-goroutine and per-mach "registers"</span></span><br><span class="line">get_tls(BX)</span><br><span class="line">LEAQ	runtime·g0(SB), CX</span><br><span class="line">MOVQ	CX, g(BX)</span><br><span class="line">LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line"><span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">MOVQ	CX, m_g0(AX)</span><br><span class="line"><span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">MOVQ	AX, g_m(CX)</span><br></pre></td></tr></table></figure></p>
<h3 id="M的一生"><a href="#M的一生" class="headerlink" title="M的一生"></a>M的一生</h3><h4 id="M的创建"><a href="#M的创建" class="headerlink" title="M的创建"></a>M的创建</h4><p><code>proc.go</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new m. It will start off with a call to fn, or else the scheduler.</span></span><br><span class="line"><span class="comment">// fn needs to be static and not a heap allocated closure.</span></span><br><span class="line"><span class="comment">// May run with m.p==nil, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="comment">// 创建一个新的m，它将从fn或者调度程序开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 根据fn和p和绑定一个m对象</span></span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">	<span class="comment">// 设置当前m的下一个p为_p_</span></span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 真正的分配os thread</span></span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 对cgo的处理</span></span><br><span class="line">	...</span><br><span class="line">	execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">	<span class="comment">// 创建一个系统线程</span></span><br><span class="line">	newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))</span><br><span class="line">	execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> mstart</span><br><span class="line">    |</span><br><span class="line">    v        找不到可执行任务，gc STW，</span><br><span class="line">+------+     任务执行时间过长，系统阻塞等   +------+</span><br><span class="line">| spin | ----------------------------&gt; |unspin| </span><br><span class="line">+------+          mstop                +------+</span><br><span class="line">    ^                                      |</span><br><span class="line">    |                                      v</span><br><span class="line">notewakeup &lt;-------------------------  notesleep</span><br></pre></td></tr></table></figure>
<h4 id="M的一些问题"><a href="#M的一些问题" class="headerlink" title="M的一些问题"></a>M的一些问题</h4><p><a href="https://github.com/golang/go/issues/14592" target="_blank" rel="noopener">https://github.com/golang/go/issues/14592</a></p>
<h3 id="P的一生"><a href="#P的一生" class="headerlink" title="P的一生"></a>P的一生</h3><h4 id="P的创建"><a href="#P的创建" class="headerlink" title="P的创建"></a>P的创建</h4><p><code>proc.go</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change number of processors. The world is stopped, sched is locked.</span></span><br><span class="line"><span class="comment">// gcworkbufs are not being modified by either the GC or</span></span><br><span class="line"><span class="comment">// the write barrier code.</span></span><br><span class="line"><span class="comment">// Returns list of Ps with local work, they need to be scheduled by the caller.</span></span><br><span class="line"><span class="comment">// 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">	old := gomaxprocs</span><br><span class="line">	<span class="comment">// 如果 gomaxprocs &lt;=0 抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"procresize: invalid arg"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">	<span class="comment">// Grow allp if necessary.</span></span><br><span class="line">	<span class="keyword">if</span> nprocs &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">		<span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line">		<span class="comment">// concurrently since it doesn't run on a P.</span></span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		<span class="keyword">if</span> nprocs &lt;= <span class="keyword">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">			allp = allp[:nprocs]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 分配nprocs个*p</span></span><br><span class="line">			nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">			<span class="comment">// Copy everything up to allp's cap so we</span></span><br><span class="line">			<span class="comment">// never lose old allocated Ps.</span></span><br><span class="line">			<span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">			allp = nallp</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize new P's</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			pp = <span class="built_in">new</span>(p)</span><br><span class="line">			pp.id = i</span><br><span class="line">			pp.status = _Pgcstop            <span class="comment">// 更改状态</span></span><br><span class="line">			pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>] <span class="comment">//将sudogcache指向sudogbuf的起始地址</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">				pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			pp.wbBuf.reset()</span><br><span class="line">			<span class="comment">// 将pp保存到allp数组里, allp[i] = pp</span></span><br><span class="line">			atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="comment">// 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">		<span class="comment">// continue to use the current P</span></span><br><span class="line">		_g_.m.p.ptr().status = _Prunning</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// release the current P and acquire allp[0]</span></span><br><span class="line">		<span class="comment">// 获取allp[0]</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			_g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		_g_.m.p = <span class="number">0</span></span><br><span class="line">		_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">		p := allp[<span class="number">0</span>]</span><br><span class="line">		p.m = <span class="number">0</span></span><br><span class="line">		p.status = _Pidle</span><br><span class="line">		<span class="comment">// 将当前的m和p绑定</span></span><br><span class="line">		acquirep(p)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> runnablePs *p</span><br><span class="line">	<span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.status = _Pidle</span><br><span class="line">		<span class="keyword">if</span> runqempty(p) &#123; <span class="comment">// 将空闲p放入空闲链表</span></span><br><span class="line">			pidleput(p)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.m.set(mget())</span><br><span class="line">			p.link.set(runnablePs)</span><br><span class="line">			runnablePs = p</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(<span class="keyword">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">var</span> int32p *<span class="keyword">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32</span></span><br><span class="line">	atomic.Store((*<span class="keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="keyword">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大</p>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">                                            acquirep(p)        </span><br><span class="line">                          不需要使用的P       P和M绑定的时候       进入系统调用       procresize()</span><br><span class="line">new(p)  -----+        +---------------+     +-----------+     +------------+    +----------+</span><br><span class="line">            |         |               |     |           |     |            |    |          |</span><br><span class="line">            |   +------------+    +---v--------+    +---v--------+    +----v-------+    +--v---------+</span><br><span class="line">            +--&gt;|  _Pgcstop  |    |    _Pidle  |    |  _Prunning |    |  _Psyscall |    |   _Pdead   |</span><br><span class="line">                +------^-----+    +--------^---+    +--------^---+    +------------+    +------------+</span><br><span class="line">                       |            |     |            |     |            |</span><br><span class="line">                       +------------+     +------------+     +------------+</span><br><span class="line">                           GC结束            releasep()        退出系统调用</span><br><span class="line">                                            P和M解绑                      </span><br><span class="line">``` </span><br><span class="line">P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。</span><br><span class="line">### G的一生</span><br><span class="line"></span><br><span class="line">#### G的创建</span><br><span class="line">`proc.go`</span><br><span class="line">```go</span><br><span class="line">// Create a new g running fn with siz bytes of arguments.</span><br><span class="line">// Put it on the queue of g&apos;s waiting to run.</span><br><span class="line">// The compiler turns a go statement into a call to this.</span><br><span class="line">// Cannot split the stack because it assumes that the arguments</span><br><span class="line">// are available sequentially after &amp;fn; they would not be</span><br><span class="line">// copied if a stack split occurred.</span><br><span class="line">//go:nosplit</span><br><span class="line">// 新建一个goroutine，</span><br><span class="line">// 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp</span><br><span class="line">// 用siz - 8 获取pc地址</span><br><span class="line">func newproc(siz int32, fn *funcval) &#123;</span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	// 用g0的栈创建G对象</span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		newproc1(fn, (*uint8)(argp), siz, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new g running fn with narg bytes of arguments starting</span></span><br><span class="line"><span class="comment">// at argp. callerpc is the address of the go statement that created</span></span><br><span class="line"><span class="comment">// this. The new g is put on the queue of g's waiting to run.</span></span><br><span class="line"><span class="comment">// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">"go of nil func value"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We could allocate a larger initial stack if necessary.</span></span><br><span class="line">	<span class="comment">// Not worth it: this is almost always an error.</span></span><br><span class="line">	<span class="comment">// 4*sizeof(uintreg): extra space added below</span></span><br><span class="line">	<span class="comment">// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</span></span><br><span class="line">	<span class="comment">// 如果函数的参数大小比2048大的话，直接panic</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">"newproc: function arguments too large for new goroutine"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从m中获取p</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="comment">// 从gfree list获取g</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="comment">// 如果没获取到g，则新建一个</span></span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead) <span class="comment">//将g的状态改为_Gdead</span></span><br><span class="line">		<span class="comment">// 添加到allg数组，防止gc扫描清除掉</span></span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"newproc1: newg missing stack"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">"newproc1: new g is not Gdead"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.RegSize + <span class="keyword">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.SpAlign - <span class="number">1</span>)                  <span class="comment">// align to spAlign</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> usesLR &#123;</span><br><span class="line">		<span class="comment">// caller's LR</span></span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">		prepGoExitFrame(sp)</span><br><span class="line">		spArg += sys.MinFrameSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// copy参数</span></span><br><span class="line">		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), <span class="keyword">uintptr</span>(narg))</span><br><span class="line">		<span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line">		<span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line">		<span class="comment">// destination is always black), then perform a</span></span><br><span class="line">		<span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line">		<span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line">		<span class="comment">// it.</span></span><br><span class="line">		<span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">			f := findfunc(fn.fn)</span><br><span class="line">			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">			<span class="comment">// We're in the prologue, so it's always stack map index 0.</span></span><br><span class="line">			bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">			bulkBarrierBitmap(spArg, spArg, <span class="keyword">uintptr</span>(narg), <span class="number">0</span>, bv.bytedata)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	<span class="comment">// 保存goexit的地址到sched.pc</span></span><br><span class="line">	newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 更改当前g的状态为_Grunnable</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		<span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">		<span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">		<span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成唯一的goid</span></span><br><span class="line">	newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将当前新生成的g，放入队列</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务</span></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in case we've cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="G的状态图"><a href="#G的状态图" class="headerlink" title="G的状态图"></a>G的状态图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                                                    +------------+</span><br><span class="line">                                    ready           |            |</span><br><span class="line">                                +------------------ |  _Gwaiting |</span><br><span class="line">                                |                   |            |</span><br><span class="line">                                |                   +------------+</span><br><span class="line">                                |                         ^ park_m</span><br><span class="line">                                V                         | </span><br><span class="line">+------------+            +------------+  execute   +------------+            +------------+    </span><br><span class="line">|            |  newproc   |            | ---------&gt; |            |   goexit   |            |</span><br><span class="line">|  _Gidle    | ---------&gt; | _Grunnable |  yield     | _Grunning  | ---------&gt; |   _Gdead   |      </span><br><span class="line">|            |            |            | &lt;--------- |            |            |            |</span><br><span class="line">+------------+            +-----^------+            +------------+            +------------+</span><br><span class="line">                                |         entersyscall |      ^ </span><br><span class="line">                                |                      V      | existsyscall</span><br><span class="line">                                |                   +------------+</span><br><span class="line">                                |   existsyscall    |            |</span><br><span class="line">                                +------------------ |  _Gsyscall |</span><br><span class="line">                                                    |            |</span><br><span class="line">                                                    +------------+</span><br></pre></td></tr></table></figure>
<p>新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable，<br>通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go/" rel="tag"># Go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/27/error/" rel="next" title="Go 异常处理机制——defer, error, panic, recover">
                <i class="fa fa-chevron-left"></i> Go 异常处理机制——defer, error, panic, recover
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/17/RUN vs CMD vs ENTRYPOINT/" rel="prev" title="RUN vs CMD vs ENTRYPOINT">
                RUN vs CMD vs ENTRYPOINT <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="欧钟艺" />
            
              <p class="site-author-name" itemprop="name">欧钟艺</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/252748371" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#M（machine）"><span class="nav-number">1.1.</span> <span class="nav-text">M（machine）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#P（processor）"><span class="nav-number">1.2.</span> <span class="nav-text">P（processor）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G（goroutine）"><span class="nav-number">1.3.</span> <span class="nav-text">G（goroutine）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程实现模型"><span class="nav-number">1.4.</span> <span class="nav-text">线程实现模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系示意图"><span class="nav-number">2.</span> <span class="nav-text">关系示意图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GPM的来由"><span class="nav-number"></span> <span class="nav-text">GPM的来由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的g0和m0"><span class="nav-number">1.</span> <span class="nav-text">特殊的g0和m0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#M的一生"><span class="nav-number">2.</span> <span class="nav-text">M的一生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#M的创建"><span class="nav-number">2.1.</span> <span class="nav-text">M的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态"><span class="nav-number">2.2.</span> <span class="nav-text">状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#M的一些问题"><span class="nav-number">2.3.</span> <span class="nav-text">M的一些问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P的一生"><span class="nav-number">3.</span> <span class="nav-text">P的一生</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#P的创建"><span class="nav-number">3.1.</span> <span class="nav-text">P的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态转换"><span class="nav-number">3.2.</span> <span class="nav-text">状态转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G的状态图"><span class="nav-number">3.3.</span> <span class="nav-text">G的状态图</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">欧钟艺</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  



  
  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
